import https from 'https';
import { WebSocket } from 'ws';

function queryString(data) {
    if (data == null)
        return '';
    var a = new URLSearchParams();
    for (var k in data)
        a.append(k, data[k]);
    return '?' + a.toString();
}
function getHttpError(error) {
    var a = error;
    a.code = 0;
    a.response = null;
    return a;
}
function getHttpResponseError(error, code, response) {
    var a = error;
    a.code = code;
    a.response = response;
    return a;
}
function hasHeader(key, o) {
    if (o.headers == null)
        return false;
    if (o.headers.hasOwnProperty(key))
        return true;
    if (o.headers.hasOwnProperty(key.toLowerCase()))
        return true;
    return false;
}
function setHeaders(headers, o) {
    if (o.body != null && !hasHeader('Content-Type', o)) {
        headers['content-type'] = 'application/json; charset=utf-8';
    }
    if (!hasHeader('Accept', o)) {
        headers['accept'] = 'application/json, text/*';
    }
}
function httpRequest(o) {
    return new Promise((resolve, reject) => {
        var { url, method, headers, timeout } = o;
        setHeaders(headers, o);
        var req = https.request(url, { method, headers, timeout }, res => {
            var body = '';
            res.setEncoding('utf8');
            res.on('error', e => reject(getHttpResponseError(e, res.statusCode, body)));
            res.on('data', chunk => body += chunk);
            res.on('end', () => resolve(body));
        });
        req.on('error', e => reject(getHttpError(e)));
        if (o.body != null) {
            req.useChunkedEncodingByDefault = true;
            req.write(JSON.stringify(o.body));
        }
        req.end();
    });
}
function httpRequestText(options) {
    return httpRequest(options);
}
async function httpRequestJson(options) {
    var response = await httpRequest(options);
    return JSON.parse(response);
}

const API_URL = 'https://api.fyers.in/api/v2/';
const DATA_URL = 'https://api.fyers.in/data-rest/v2/';
const SYMBOLS_URL = 'https://public.fyers.in/sym_details/';
function requestStep(auth, method, path, query, body) {
    var url = path + queryString(query);
    var headers = {};
    if (auth != null)
        headers['authorization'] = auth.app_id + ':' + auth.access_token;
    return { url, method, headers, body };
}
function requestText(auth, method, path, query, body) {
    return httpRequestText(requestStep(auth, method, path, query, body));
}
function requestJson(auth, method, path, query, body) {
    return httpRequestJson(requestStep(auth, method, path, query, body));
}
function requestApi(auth, method, path, query, body) {
    return requestJson(auth, method, API_URL + path, query, body);
}
function requestData(auth, method, path, query, body) {
    return requestJson(auth, method, DATA_URL + path, query, body);
}
function requestSymbols(auth, method, path, query, body) {
    return requestText(auth, method, SYMBOLS_URL + path, query, body);
}
function loginStep1$1(options) {
    return requestStep(null, 'GET', API_URL + 'generate-authcode', options, null);
}
function loginStep2$1(options) {
    return requestStep(null, 'POST', API_URL + 'validate-authcode', null, options);
}
function getProfile$1(auth) {
    return requestApi(auth, 'GET', 'profile', null, null);
}
function getFunds$1(auth) {
    return requestApi(auth, 'GET', 'funds', null, null);
}
function getHoldings$1(auth) {
    return requestApi(auth, 'GET', 'holdings', null, null);
}
function getOrder$1(auth, options) {
    return requestApi(auth, 'GET', 'orders', options, null);
}
function getOrders$1(auth) {
    return requestApi(auth, 'GET', 'orders', null, null);
}
function getPositions$1(auth) {
    return requestApi(auth, 'GET', 'positions', null, null);
}
function getTrades$1(auth) {
    return requestApi(auth, 'GET', 'tradebook', null, null);
}
function placeOrder$1(auth, options) {
    return requestApi(auth, 'POST', 'orders', null, options);
}
function placeOrders$1(auth, options) {
    return requestApi(auth, 'POST', 'orders-multi', null, options);
}
function modifyOrder$1(auth, options) {
    return requestApi(auth, 'PUT', 'orders', null, options);
}
function modifyOrders$1(auth, options) {
    return requestApi(auth, 'PUT', 'orders-multi', null, options);
}
function cancelOrder$1(auth, options) {
    return requestApi(auth, 'DELETE', 'orders', null, options);
}
function cancelOrders$1(auth, options) {
    return requestApi(auth, 'DELETE', 'orders-multi', null, options);
}
function exitPosition$1(auth, options) {
    return requestApi(auth, 'DELETE', 'positions', null, options);
}
function exitAllPositions$1(auth) {
    return requestApi(auth, 'DELETE', 'positions', null, {});
}
function convertPosition$1(auth, options) {
    return requestApi(auth, 'PUT', 'positions', null, options);
}
function getMarketStatus$1(auth) {
    return requestApi(auth, 'GET', 'market-status', null, null);
}
function getMarketHistory$1(auth, options) {
    return requestData(auth, 'GET', 'history/', options, null);
}
function getMarketQuotes$1(auth, options) {
    return requestData(auth, 'GET', 'quotes/', options, null);
}
function getMarketDepth$1(auth, options) {
    return requestData(auth, 'GET', 'depth/', options, null);
}
function getSymbolMaster$1(auth, options) {
    var { exchange, segment } = options;
    return requestSymbols(null, 'GET', exchange + '_' + segment + '.csv', null, null);
}
function generateEdisTpin$1(auth) {
    return requestApi(auth, 'GET', 'tpin', null, null);
}
function getEdisTransactions$1(auth) {
    return requestApi(auth, 'GET', 'details', null, null);
}
function submitEdisHoldingsStep$1(auth, options) {
    return requestStep(auth, 'POST', 'index', null, options);
}
function inquireEdisTransaction$1(auth, options) {
    return requestApi(auth, 'POST', 'inquiry', null, options);
}

var http = /*#__PURE__*/Object.freeze({
    __proto__: null,
    API_URL: API_URL,
    DATA_URL: DATA_URL,
    SYMBOLS_URL: SYMBOLS_URL,
    cancelOrder: cancelOrder$1,
    cancelOrders: cancelOrders$1,
    convertPosition: convertPosition$1,
    exitAllPositions: exitAllPositions$1,
    exitPosition: exitPosition$1,
    generateEdisTpin: generateEdisTpin$1,
    getEdisTransactions: getEdisTransactions$1,
    getFunds: getFunds$1,
    getHoldings: getHoldings$1,
    getMarketDepth: getMarketDepth$1,
    getMarketHistory: getMarketHistory$1,
    getMarketQuotes: getMarketQuotes$1,
    getMarketStatus: getMarketStatus$1,
    getOrder: getOrder$1,
    getOrders: getOrders$1,
    getPositions: getPositions$1,
    getProfile: getProfile$1,
    getSymbolMaster: getSymbolMaster$1,
    getTrades: getTrades$1,
    inquireEdisTransaction: inquireEdisTransaction$1,
    loginStep1: loginStep1$1,
    loginStep2: loginStep2$1,
    modifyOrder: modifyOrder$1,
    modifyOrders: modifyOrders$1,
    placeOrder: placeOrder$1,
    placeOrders: placeOrders$1,
    submitEdisHoldingsStep: submitEdisHoldingsStep$1
});

const MARKET_DATA_URL = "wss://api.fyers.in/socket/v2/dataSock";
const ORDER_UPDATE_URL = "wss://api.fyers.in/socket/v2/orderSock";
const MARKET_DATA_QUERY = "user-agent=fyers-api&type=symbolUpdate";
const ORDER_UPDATE_QUERY = "user-agent=fyers-api&type=orderUpdate";
const PING_INTERVAL = 5000;
function writeHeader(a, x, i) {
    a.token = x.getBigUint64(i + 0);
    a.tt = x.getUint32(i + 8);
    a.fyCode = x.getUint16(i + 12);
    a.marketStat = x.getUint16(i + 14);
    a.pktlen = x.getUint16(i + 16);
    a.L2 = x.getUint8(i + 18);
}
function writeOiData(a, x, i) {
    a.oi = BigInt(x.getUint32(i + 0));
    a.pdoi = BigInt(x.getUint32(i + 4));
}
function writeCommonData(a, x, i, hasOi) {
    a.price_conv = x.getUint32(i + 0);
    a.ltp = x.getUint32(i + 4);
    a.open_price = x.getUint32(i + 8);
    a.high_price = x.getUint32(i + 12);
    a.low_price = x.getUint32(i + 16);
    a.prev_close_price = x.getUint32(i + 20);
    a.o = x.getUint32(i + 24);
    a.h = x.getUint32(i + 28);
    a.l = x.getUint32(i + 32);
    a.c = x.getUint32(i + 36);
    a.v = x.getBigUint64(i + 40);
    if (!hasOi)
        return;
    a.oi = x.getBigUint64(i + 48);
    a.pdoi = x.getBigUint64(i + 56);
}
function writeL1Data(a, x, i, bidAsk) {
    a.LTQ = x.getUint32(i + 0);
    a.L2_LTT = x.getUint32(i + 4);
    a.ATP = x.getUint32(i + 8);
    a.volume = x.getUint32(i + 12);
    a.tot_buy = x.getBigUint64(i + 16);
    a.tot_sell = x.getBigUint64(i + 24);
    if (!bidAsk)
        return;
    a.bid = x.getUint32(i + 32);
    a.ask = x.getUint32(i + 36);
}
function toL2MarketOffer(x, i) {
    return {
        price: x.getUint32(i + 0),
        volume: x.getUint32(i + 4),
        ord: x.getUint32(i + 8),
    };
}
function writeL2Data(a, x, i) {
    var bids = [], asks = [];
    for (var j = 0; j < 60; j += 12) {
        bids.push(toL2MarketOffer(x, i + j));
        asks.push(toL2MarketOffer(x, i + j + 60));
    }
    a.bids = bids;
    a.asks = asks;
}
function writeMarketData(a, x, i) {
    writeHeader(a, x, i + 0);
    var hasOi = a.fyCode === 7202 || a.fyCode === 31038;
    var l1Off = hasOi ? 88 : 72;
    if (a.fyCode === 7202)
        writeOiData(a, x, i + 24);
    else
        writeCommonData(a, x, i + 24, hasOi);
    if (a.fyCode === 7208 || a.fyCode === 31038)
        writeL1Data(a, x, i + l1Off, a.L2 !== 1);
    if (a.L2 === 1)
        writeL2Data(a, x, i + l1Off + 32);
}
function toMarketData(x, i) {
    var a = {
        token: BigInt(0),
        tt: 0,
        fyCode: 0,
        marketStat: 0,
        pktlen: 0,
        L2: 0,
        price_conv: 0,
        ltp: 0,
        open_price: 0,
        high_price: 0,
        low_price: 0,
        prev_close_price: 0,
        o: 0,
        h: 0,
        l: 0,
        c: 0,
        v: BigInt(0),
        oi: BigInt(0),
        pdoi: BigInt(0),
        LTQ: 0,
        L2_LTT: 0,
        ATP: 0,
        volume: 0,
        tot_buy: BigInt(0),
        tot_sell: BigInt(0),
        bid: 0,
        ask: 0,
        bids: null,
        asks: null,
    };
    writeMarketData(a, x, i);
    return a;
}
class Connection extends WebSocket {
    constructor() {
        super(...arguments);
        this.recievers = [];
    }
}
function waitResponse(conn) {
    return new Promise((resolve, reject) => conn.recievers.push({ resolve, reject }));
}
function connectOrderUpdate$1(auth, fn) {
    return new Promise((resolve, reject) => {
        var { app_id, access_token } = auth;
        var query = `${ORDER_UPDATE_QUERY}&access_token=${app_id}:${access_token}`;
        var conn = new Connection(`${ORDER_UPDATE_URL}?${query}`);
        var ping = setInterval(() => {
            if (conn.readyState !== WebSocket.OPEN)
                return;
            conn.send("ping");
        }, PING_INTERVAL);
        conn.binaryType = "arraybuffer";
        conn.onerror = e => {
            for (var r of conn.recievers)
                r.reject(e.error);
            clearInterval(ping);
            reject(e.error);
        };
        conn.onopen = () => resolve(conn);
        conn.onmessage = e => {
            if (typeof e.data !== "string")
                return;
            if (e.data === "pong")
                return;
            var x = JSON.parse(e.data);
            fn(x);
            if (x.hasOwnProperty("d") || x.code === 0)
                return;
            if (conn.recievers.length > 0)
                conn.recievers.shift().resolve(x);
        };
    });
}
function subscribeOrderUpdate$1(conn) {
    var req = { T: "SUB_ORD", SLIST: ["orderUpdate"], SUB_T: 1 };
    conn.send(JSON.stringify(req));
    return waitResponse(conn);
}
function unsubscribeOrderUpdate$1(conn) {
    var req = { T: "SUB_ORD", SLIST: ["orderUpdate"], SUB_T: 0 };
    conn.send(JSON.stringify(req));
    return waitResponse(conn);
}
function connectMarketData$1(auth, fn) {
    return new Promise((resolve, reject) => {
        var { app_id, access_token } = auth;
        var query = `${MARKET_DATA_QUERY}&access_token=${app_id}:${access_token}`;
        var conn = new Connection(`${MARKET_DATA_URL}?${query}`);
        var ping = setInterval(() => {
            if (conn.readyState !== WebSocket.OPEN)
                return;
            conn.send("ping");
        }, PING_INTERVAL);
        conn.binaryType = "arraybuffer";
        conn.onerror = e => {
            for (var r of conn.recievers)
                r.reject(e.error);
            clearInterval(ping);
            reject(e.error);
        };
        conn.onopen = () => resolve(conn);
        conn.onmessage = e => {
            if (typeof e.data === "string") {
                if (e.data === "pong")
                    return;
                var x = JSON.parse(e.data);
                fn(x);
                if (x.hasOwnProperty("d") || x.code === 0)
                    return;
                if (conn.recievers.length > 0)
                    conn.recievers.shift().resolve(x);
            }
            else {
                var binary = new DataView(e.data);
                fn({ s: "ok", d: toMarketData(binary, 0) });
            }
        };
    });
}
function subscribeMarketQuote$1(conn, symbols) {
    var req = { T: "SUB_DATA", TLIST: symbols, SUB_T: 1 };
    conn.send(JSON.stringify(req));
    return waitResponse(conn);
}
function subscribeMarketDepth$1(conn, symbols) {
    var req = { T: "SUB_L2", L2LIST: symbols, SUB_T: 1 };
    conn.send(JSON.stringify(req));
    return waitResponse(conn);
}
function unsubscribeMarketQuote$1(conn, symbols) {
    var req = { T: "SUB_DATA", TLIST: symbols, SUB_T: 0 };
    conn.send(JSON.stringify(req));
    return waitResponse(conn);
}
function unsubscribeMarketDepth$1(conn, symbols) {
    var req = { T: "SUB_L2", L2LIST: symbols, SUB_T: 0 };
    conn.send(JSON.stringify(req));
    return waitResponse(conn);
}

var websocket = /*#__PURE__*/Object.freeze({
    __proto__: null,
    Connection: Connection,
    MARKET_DATA_URL: MARKET_DATA_URL,
    ORDER_UPDATE_URL: ORDER_UPDATE_URL,
    connectMarketData: connectMarketData$1,
    connectOrderUpdate: connectOrderUpdate$1,
    subscribeMarketDepth: subscribeMarketDepth$1,
    subscribeMarketQuote: subscribeMarketQuote$1,
    subscribeOrderUpdate: subscribeOrderUpdate$1,
    unsubscribeMarketDepth: unsubscribeMarketDepth$1,
    unsubscribeMarketQuote: unsubscribeMarketQuote$1,
    unsubscribeOrderUpdate: unsubscribeOrderUpdate$1
});

const TO_EXCHANGE = new Map([
    [10, "NSE"],
    [11, "MCX"],
    [12, "BSE"],
]);
const EXCHANGE_DESCRIPTION = new Map([
    ["NSE", "National Stock Exchange"],
    ["MCX", "Multi Commodity Exchange"],
    ["BSE", "Bombay Stock Exchange"],
]);
function toExchange(x) {
    return TO_EXCHANGE.get(x);
}
function exchangeDescription(code) {
    return EXCHANGE_DESCRIPTION.get(code);
}
function exchange(desc) {
    if (/bse|native|bombay|mumbai/i.test(desc))
        return "BSE";
    if (/\bcom\b|mcx|multi|commodit/i.test(desc))
        return "MCX";
    return "NSE";
}
const TO_SEGMENT = new Map([
    [10, "CM"],
    [11, "FO"],
    [12, "CD"],
    [20, "COM"],
]);
const SEGMENT_DESCRIPTION = new Map([
    ["CM", "Capital Market"],
    ["FO", "Equity Derivatives"],
    ["CD", "Currency Derivatives"],
    ["COM", "Commodity Derivatives"],
]);
function toSegment(x) {
    return TO_SEGMENT.get(x);
}
function segmentDescription(code) {
    return SEGMENT_DESCRIPTION.get(code);
}
function segment(desc) {
    if (/\bcom\b|mcx|multi|commodit/i.test(desc))
        return "COM";
    if (/\bcd\b|currenc/i.test(desc))
        return "CD";
    if (/\bfn?o\b|fut|opt|deriv/i.test(desc))
        return "FO";
    return "CM";
}
const TO_POSITION_SIDE = new Map([
    [1, "LONG"],
    [-1, "SHORT"],
    [0, "CLOSED"],
]);
const FROM_POSITION_SIDE = new Map([
    ["LONG", 1],
    ["SHORT", -1],
    ["CLOSED", 0],
]);
const POSITION_SIDE_DESCRIPTION = new Map([
    ["LONG", "Long position"],
    ["SHORT", "Short position"],
    ["CLOSED", "Closed position"],
]);
function toPositionSide(x) {
    return TO_POSITION_SIDE.get(x);
}
function fromPositionSide(x) {
    return FROM_POSITION_SIDE.get(x);
}
function positionSideDescription(code) {
    return POSITION_SIDE_DESCRIPTION.get(code);
}
function positionSide(desc) {
    if (/up|buy|long|rally/i.test(desc))
        return "LONG";
    if (/down|sell|short|crash/i.test(desc))
        return "SHORT";
    return "CLOSED";
}
const TO_ORDER_SIDE = new Map([
    [1, "BUY"],
    [-1, "SELL"],
]);
const FROM_ORDER_SIDE = new Map([
    ["BUY", 1],
    ["SELL", -1],
]);
const ORDER_SIDE_DESCRIPTION = new Map([
    ["BUY", "Buy"],
    ["SELL", "Sell"],
]);
function toOrderSide(x) {
    return TO_ORDER_SIDE.get(x);
}
function fromOrderSide(x) {
    return FROM_ORDER_SIDE.get(x);
}
function orderSideDescription(code) {
    return ORDER_SIDE_DESCRIPTION.get(code);
}
function orderSide(desc) {
    return /down|sell|short|crash/i.test(desc) ? "SELL" : "BUY";
}
const TO_ORDER_SOURCE = new Map([
    ["M", "MOBILE"],
    ["W", "WEB"],
    ["R", "ONE"],
    ["A", "ADMIN"],
    ["ITS", "API"],
]);
const ORDER_SOURCE_DESCRIPTION = new Map([
    ["MOBILE", "FYERS Mobile"],
    ["WEB", "FYERS Web"],
    ["ONE", "FYERS One"],
    ["ADMIN", "Admin"],
    ["API", "FYERS API"],
]);
function toOrderSource(x) {
    return TO_ORDER_SOURCE.get(x);
}
function orderSourceDescription(code) {
    return ORDER_SOURCE_DESCRIPTION.get(code);
}
function orderSource(desc) {
    if (/its|api|sys/i.test(desc))
        return "API";
    if (/one|desk/i.test(desc))
        return "ONE";
    if (/mob|app/i.test(desc))
        return "MOBILE";
    if (/admin/i.test(desc))
        return "ADMIN";
    return "WEB";
}
const TO_ORDER_STATUS = new Map([
    [1, "CANCELLED"],
    [2, "TRADED"],
    [4, "TRANSIT"],
    [5, "REJECTED"],
    [6, "PENDING"],
    [7, "EXPIRED"],
]);
const ORDER_STATUS_DESCRIPTION = new Map([
    ["CANCELLED", "Cancelled"],
    ["TRADED", "Traded / Filled"],
    ["TRANSIT", "Transit"],
    ["REJECTED", "Rejected"],
    ["PENDING", "Pending"],
    ["EXPIRED", "Expired"],
]);
const ORDER_STATUS_CODE = new Map([
    ["C", "CANCELLED"],
    ["F", "TRADED"],
    ["T", "TRANSIT"],
    ["R", "REJECTED"],
    ["P", "PENDING"],
    ["E", "EXPIRED"],
]);
function toOrderStatus(x) {
    return TO_ORDER_STATUS.get(x);
}
function orderStatusDescription(code) {
    return ORDER_STATUS_DESCRIPTION.get(code);
}
function orderStatus(desc) {
    var key = desc.charAt(0).toUpperCase();
    if (/traded/i.test(desc))
        key = "F";
    return ORDER_STATUS_CODE.get(key);
}
const TO_ORDER_TYPE = new Map([
    [1, "LIMIT"],
    [2, "MARKET"],
    [3, "SL_MARKET"],
    [4, "SL_LIMIT"],
]);
const FROM_ORDER_TYPE = new Map([
    ["LIMIT", 1],
    ["MARKET", 2],
    ["SL_MARKET", 3],
    ["SL_LIMIT", 4],
]);
const ORDER_TYPE_DESCRIPTION = new Map([
    ["LIMIT", "Limit order"],
    ["MARKET", "Market order"],
    ["SL_MARKET", "Stop order (SL-M)"],
    ["SL_LIMIT", "Stoplimit order (SL-L)"],
]);
const ORDER_TYPE_CODE = new Map([
    ["L", "LIMIT"],
    ["M", "MARKET"],
    ["S", "SL_MARKET"],
    ["R", "SL_LIMIT"],
]);
function toOrderType(x) {
    return TO_ORDER_TYPE.get(x);
}
function fromOrderType(x) {
    return FROM_ORDER_TYPE.get(x);
}
function orderTypeDescription(code) {
    return ORDER_TYPE_DESCRIPTION.get(code);
}
function orderType(desc) {
    var key = desc.charAt(0).toUpperCase();
    if (/s.+l(?!oss)/i.test(desc))
        key = "R";
    return ORDER_TYPE_CODE.get(key);
}
const ORDER_VALIDITY_DESCRIPTION = new Map([
    ["DAY", "End of day validity"],
    ["IOC", "Immediate or Cancel validity"],
]);
function toOrderValidity(x) {
    return x;
}
function orderValidityDescription(code) {
    return ORDER_VALIDITY_DESCRIPTION.get(code);
}
function orderValidity(desc) {
    return /ioc|cancel|immediate/i.test(desc) ? "IOC" : "DAY";
}
const OPTION_TYPE_DESCRIPTION = new Map([
    ["CE", "Call option"],
    ["PE", "Put option"],
]);
function optionTypeDescription(code) {
    return OPTION_TYPE_DESCRIPTION.get(code);
}
function optionType(desc) {
    return /pe|put|sell/i.test(desc) ? "PE" : "CE";
}
const DERIVATIVE_TYPE_DESCRIPTION = new Map([
    ["FUT", "Future"],
    ["CE", "Call option"],
    ["PE", "Put option"],
]);
function derivativeTypeDescription(code) {
    return DERIVATIVE_TYPE_DESCRIPTION.get(code);
}
function derivativeType(desc) {
    return /fut|lat|buy/.test(desc) ? "FUT" : optionType(desc);
}
const HOLDING_TYPE_DESCRIPTION = new Map([
    ["T1", "The shares are purchased but not yet delivered to the demat account"],
    ["HLD", "The shares are purchased and are available in the demat account"],
]);
function toHoldingType(x) {
    return x;
}
function holdingTypeDescription(code) {
    return HOLDING_TYPE_DESCRIPTION.get(code);
}
function holdingType(desc) {
    return /un|not|pend|t1/i.test(desc) ? "T1" : "HLD";
}
const PRODUCT_TYPE_DESCRIPTION = new Map([
    ["CNC", "Cash N Carry or Delivery Order, for equity only"],
    ["INTRADAY", "Intraday Order, applicable for all segments"],
    ["MARGIN", "Margin Order, applicable only for derivatives"],
    ["CO", "Cover Order"],
    ["BO", "Bracket Order"],
]);
const PRODUCT_TYPE_CODE = new Map([
    ["D", "CNC"],
    ["I", "INTRADAY"],
    ["M", "MARGIN"],
    ["C", "CO"],
    ["B", "BO"],
]);
function toProductType(x) {
    return x;
}
function fromProductType(x) {
    return x;
}
function productTypeDescription(code) {
    return PRODUCT_TYPE_DESCRIPTION.get(code);
}
function productType(desc) {
    var key = desc.charAt(0).toUpperCase();
    if (/cnc|cash|carry|deliver/i.test(desc))
        key = "D";
    return PRODUCT_TYPE_CODE.get(key);
}
const TO_INSTRUMENT_TYPE = new Map([
    [0, "EQ"],
    [1, "PREFSHARES"],
    [2, "DEBENTURES"],
    [3, "WARRANTS"],
    [4, "MISC"],
    [10, "INDEX"],
    [11, "FUTIDX"],
    [12, "FUTIVX"],
    [13, "FUTSTK"],
    [14, "OPTIDX"],
    [15, "OPTSTK"],
    [16, "FUTCUR"],
    [17, "FUTIRT"],
    [18, "FUTIRC"],
    [19, "OPTCUR"],
    [20, "UNDCUR"],
    [21, "UNDIRC"],
    [22, "UNDIRT"],
    [23, "UNDIRD"],
    [24, "INDEX_CD"],
    [25, "FUTIRD"],
    [30, "FUTCOM"],
    [31, "OPTFUT"],
    [32, "OPTCOM"],
]);
const INSTRUMENT_TYPE_DESCRIPTION = new Map([
    ["EQ", "Equity Shares"],
    ["PREFSHARES", "Preference Shares"],
    ["DEBENTURES", "Collateral-free Debt"],
    ["WARRANTS", "Warrants on Stock"],
    ["MISC", "Miscellaneous"],
    ["INDEX", "Stock Market Index"],
    ["FUTIDX", "Futures on Index"],
    ["FUTIVX", "Futures on Volatility Index"],
    ["FUTSTK", "Futures on Stock"],
    ["OPTIDX", "Options on Index"],
    ["OPTSTK", "Options on Stock"],
    ["FUTCUR", "Futures on Currency"],
    ["FUTIRT", "Futures on Government of India Treasury Bills"],
    ["FUTIRC", "Futures on Government of India Bonds"],
    ["OPTCUR", "Options on Currency"],
    ["UNDCUR", "Underlying on Currency"],
    ["UNDIRC", "Underlying on Government of Bonds"],
    ["UNDIRT", "Underlying on Government of India Treasury Bills"],
    ["UNDIRD", "Underlying on 10 Year Notional coupon bearing GOI security"],
    ["INDEX_CD", "Market-indexed Certificate of deposit"],
    ["FUTIRD", "Futures on 10 Year Notional coupon bearing GOI security"],
    ["FUTCOM", "Futures on Commodity"],
    ["OPTFUT", "Options on Commodity Futures"],
    ["OPTCOM", "Options on Commodity"],
]);
function toInstrumentType(x) {
    return TO_INSTRUMENT_TYPE.get(x);
}
function instrumentTypeDescription(code) {
    return INSTRUMENT_TYPE_DESCRIPTION.get(code);
}
function instrumentType(desc) {
    var fut = /fut|future/i.test(desc);
    var opt = /opt|option/i.test(desc);
    var idx = /idx|index/i.test(desc);
    var und = /und|underlying/i.test(desc);
    if (/com(\b|$)|commodit/i.test(desc)) {
        if (opt)
            return fut ? "OPTFUT" : "OPTCOM";
        else if (idx)
            return "FUTIDX";
        else
            return "FUTCOM";
    }
    else if (/(^|\b)und|cd(\b|$)|ir[cdt](\b|$)|cur|gov|bond|trea|coup/i.test(desc)) {
        if (/irc(\b|$)|bond/i.test(desc))
            return und ? "UNDIRC" : "FUTIRC";
        else if (/ird(\b|$)|coup/i.test(desc))
            return und ? "UNDIRD" : "FUTIRD";
        else if (/irt(\b|$)|trea/i.test(desc))
            return und ? "UNDIRT" : "FUTIRT";
        else
            return idx ? "INDEX_CD" : (opt ? "OPTCUR" : "FUTCUR");
    }
    else if (fut || opt) {
        if (/ivx|volatil/i.test(desc))
            return "FUTIVX";
        else if (idx)
            return opt ? "OPTIDX" : "FUTIDX";
        else
            return opt ? "OPTSTK" : "FUTSTK";
    }
    else {
        if (idx)
            return "INDEX";
        else if (/misc/i.test(desc))
            return "MISC";
        else if (/warrant/i.test(desc))
            return "WARRANTS";
        else if (/deb/i.test(desc))
            return "DEBENTURES";
        else if (/pref/i.test(desc))
            return "PREFSHARES";
    }
    return "EQ";
}
const RSYMBOL_NAME = /^\w+:(.+?)-\w+$|^\w+:(.+?)\d{2}\w{3}FUT$|^\w+:(.+?)\d{2}\w{3}[\d\.]+[CP]E$|^\w+:(.+?)\d{2}\w{1}\d{2}[\d\.]+[CP]E$/;
function toSymbolDetails(row) {
    var [token, description, , lotSize, , isin, , , , symbol] = row.split(',');
    return { symbol, token, description, lotSize: parseInt(lotSize, 10), isin: isin || "" };
}
function symbolName(code) {
    var m = RSYMBOL_NAME.exec(code);
    return m[1] || m[2] || m[3] || m[4];
}
function symbolExchange(code) {
    var i = code.indexOf(":");
    return code.substring(0, i);
}
function symbolSeries(code) {
    var i = code.lastIndexOf("-");
    return i > 0 ? code.substring(i) : null;
}
function symbolOptionType(code) {
    var a = code.substring(code.length - 2);
    return a === "CE" || a === "PE" ? a : null;
}
function symbolDerivativeType(code) {
    var m = /(?:FUT|CE|PE)$/.exec(code);
    return m != null ? m[0] : null;
}
function symbolStrikePrice(code) {
    var RSTRIKE = /([\d\.]+)[CP]E$/, m = RSTRIKE.exec(code);
    return m != null ? parseFloat(m[1]) : 0;
}
function symbolToken(code, map) {
    return map.get(code).token;
}
function symbolDescription(code, map) {
    return map.get(code).description;
}
function symbolIsin(code, map) {
    return map.get(code).isin;
}
function symbolLotSize(code, map) {
    return map.get(code).lotSize;
}
function fromAuthorization(x) {
    return {
        app_id: x.appId,
        access_token: x.accessToken,
    };
}
function fromLoginStep1Request(x) {
    return {
        client_id: x.appId,
        redirect_uri: x.redirectUrl,
        response_type: "code",
        state: x.state,
    };
}
function fromLoginStep2Request(x) {
    return {
        grant_type: "authorization_code",
        appIdHash: x.appHash,
        code: x.authorizationCode,
    };
}
function toProfile(x) {
    var d = x.data;
    return {
        id: d.fy_id,
        email: d.email_id,
        name: d.name,
        pan: d.PAN,
    };
}
function toFunds(x) {
    var e = {};
    var c = {};
    for (var l of x.fund_limit) {
        switch (l.id) {
            case 9 :
                e.start = l.equityAmount;
                c.start = l.commodityAmount;
                break;
            case 6 :
                e.deposits = l.equityAmount;
                c.deposits = l.commodityAmount;
                break;
            case 4 :
                e.realizedReturns = l.equityAmount;
                c.realizedReturns = l.commodityAmount;
                break;
            case 5 :
                e.collaterals = l.equityAmount;
                c.collaterals = l.commodityAmount;
                break;
            case 8 :
                e.adhoc = l.equityAmount;
                c.adhoc = l.commodityAmount;
                break;
            case 2 :
                e.utilized = l.equityAmount;
                c.utilized = l.commodityAmount;
                break;
            case 7 :
                e.receivables = l.equityAmount;
                c.receivables = l.commodityAmount;
                break;
            case 10 :
                e.available = l.equityAmount;
                c.available = l.commodityAmount;
                break;
            case 3 :
                e.clear = l.equityAmount;
                c.clear = l.commodityAmount;
                break;
            case 1 :
                e.total = l.equityAmount;
                c.total = l.commodityAmount;
                break;
        }
    }
    return { equity: e, commodity: c };
}
function toHolding(x) {
    return {
        isin: x.isin,
        symbol: x.symbol,
        token: x.fytoken,
        exchange: toExchange(x.exchange),
        type: toHoldingType(x.holdingType),
        quantity: x.quantity,
        remainingQuantity: x.remainingQuantity,
        buyPrice: x.costPrice,
        buyValue: x.costPrice * x.quantity,
        currentPrice: x.ltp,
        currentValue: x.marketVal,
        returns: x.pl,
        returnsPercent: x.pl / (x.costPrice * x.quantity),
    };
}
function toHoldingsOverall(xs, x) {
    var settledCount = 0;
    for (var h of xs)
        if (h.holdingType === "HLD")
            settledCount++;
    return {
        count: x.count_total,
        settledCount,
        investedValue: x.total_investment,
        currentValue: x.total_current_value,
        returns: x.total_pl,
        returnsPercent: x.pnl_perc,
    };
}
function toHoldings(x) {
    return {
        details: x.holdings.map(toHolding),
        overall: toHoldingsOverall(x.holdings, x.overall),
    };
}
function toOrder(x) {
    return {
        id: x.id,
        symbol: x.symbol,
        token: x.fytoken,
        name: x.ex_sym,
        description: x.description,
        segment: toSegment(x.segment),
        instrument: toInstrumentType(x.instrument),
        exchange: toExchange(x.exchange),
        type: toOrderType(x.type),
        side: toOrderSide(x.side),
        productType: toProductType(x.productType),
        source: toOrderSource(x.source) || null,
        status: toOrderStatus(x.status),
        offline: x.offlineOrder === "True",
        limitPrice: x.limitPrice,
        stopPrice: x.stopPrice,
        quantity: x.qty,
        remainingQuantity: x.remainingQuantity,
        tradedQuantity: x.filledQty,
        disclosedQuantity: x.discloseQty,
        remainingDisclosedQuantity: x.dqQtyRem,
        validity: toOrderValidity(x.orderValidity),
        date: x.orderDateTime,
        parentId: x.parentId || null,
        priceChange: x.ch,
        priceChangePercent: x.chp,
        currentPrice: x.lp,
        tradedPrice: x.tradedPrice,
        message: x.message,
        pan: x.pan || null,
        clientId: x.clientId || null,
    };
}
function toOrdersOverall(x) {
    var a = {
        count: 0,
        openCount: 0,
        closedCount: 0,
        quantity: 0,
        remainingQuantity: 0,
        tradedQuantity: 0,
        disclosedQuantity: 0,
        remainingDisclosedQuantity: 0,
    };
    for (var o of x) {
        a.count++;
        a.openCount += o.status === 6  || o.status === 4  ? 1 : 0;
        a.quantity += o.qty;
        a.remainingQuantity += o.remainingQuantity;
        a.tradedQuantity += o.filledQty;
        a.disclosedQuantity += o.discloseQty;
        a.remainingDisclosedQuantity += o.dqQtyRem;
    }
    a.closedCount = a.count - a.openCount;
    return a;
}
function toOrders(x) {
    return {
        details: x.orderBook.map(toOrder),
        overall: toOrdersOverall(x.orderBook),
    };
}
function toPosition(x) {
    return {
        id: x.id,
        symbol: x.symbol,
        token: x.fytoken,
        segment: toSegment(x.segment),
        productType: toProductType(x.productType),
        side: toPositionSide(x.side),
        quantity: x.qty,
        quantityMultiplier: x.qtyMulti_com,
        buyPrice: x.buyAvg,
        buyQuantity: x.buyQty,
        buyValue: x.buyVal,
        sellPrice: x.sellAvg,
        sellQuantity: x.sellQty,
        sellValue: x.sellVal,
        netPrice: x.netAvg,
        netQuantity: x.netQty,
        returns: x.pl,
        realizedReturns: x.realized_profit,
        unrealizedReturns: x.unrealized_profit,
        crossCurrency: x.crossCurrency === "Y",
        rbiRefRate: x.rbiRefRate,
        currentPrice: x.ltp,
    };
}
function toPositionsOverall(xs, x) {
    var buyValue = 0, sellValue = 0;
    for (var p of xs) {
        buyValue += p.buyVal;
        sellValue += p.sellVal;
    }
    return {
        count: x.count_total,
        openCount: x.count_open,
        closedCount: x.count_total - x.count_open,
        buyValue,
        sellValue,
        returns: x.pl_total,
        realizedReturns: x.pl_realized,
        unrealizedReturns: x.pl_unrealized,
    };
}
function toPositions(x) {
    return {
        details: x.netPositions.map(toPosition),
        overall: toPositionsOverall(x.netPositions, x.overall),
    };
}
function toTrade(x) {
    return {
        id: x.id,
        orderId: x.orderNumber,
        symbol: x.symbol,
        token: x.fyToken,
        segment: toSegment(x.segment),
        exchange: toExchange(x.exchange),
        side: toOrderSide(x.transactionType),
        productType: toProductType(x.productType),
        orderType: toOrderType(x.orderType),
        orderDate: x.orderDateTime,
        price: x.tradePrice,
        quantity: x.tradedQty,
        value: x.tradeValue,
        clientId: x.clientId,
    };
}
function toTradesOverall(x) {
    var a = {
        count: 0,
        quantity: 0,
        value: 0,
    };
    for (var t of x) {
        a.count++;
        a.quantity += t.tradedQty;
        a.value += t.tradeValue;
    }
    return a;
}
function toTrades(x) {
    return {
        details: x.tradeBook.map(toTrade),
        overall: toTradesOverall(x.tradeBook),
    };
}
function fromPlaceOrder(x) {
    return {
        symbol: x.symbol,
        type: fromOrderType(x.type || "MARKET"),
        side: fromOrderSide(x.side || "BUY"),
        productType: x.productType || "CNC",
        limitPrice: x.limitPrice || 0,
        stopPrice: x.stopPrice || 0,
        qty: x.quantity,
        disclosedQty: x.disclosedQuantity || 0,
        validity: x.validity || "DAY",
        offlineOrder: x.offline ? "True" : "False",
        stopLoss: x.stopLoss || 0,
        takeProfit: x.takeProfit || 0,
    };
}
function fromModifyOrder(x) {
    return {
        id: x.id,
        type: fromOrderType(x.type),
        qty: x.quantity,
        disclosedQty: x.disclosedQuantity,
        limitPrice: x.limitPrice,
        stopPrice: x.stopPrice,
    };
}
function fromConvertPosition(x) {
    return {
        symbol: x.symbol,
        positionSide: fromPositionSide(x.side || "LONG"),
        convertQty: x.quantity,
        convertFrom: fromProductType(x.fromProductType || "INTRADAY"),
        convertTo: fromProductType(x.toProductType || "CNC"),
    };
}
function toMarketStatus(x) {
    return {
        exchange: toExchange(x.exchange),
        segment: toSegment(x.segment),
        type: x.market_type,
        status: x.status,
    };
}
function toMarketsStatusOverall(x) {
    var a = {
        count: 0,
        openCount: 0,
        closedCount: 0,
    };
    for (var s of x) {
        a.count++;
        if (s.status === "OPEN")
            a.openCount++;
        else
            a.closedCount++;
    }
    return a;
}
function toMarketsStatus(x) {
    return {
        details: x.marketStatus.map(toMarketStatus),
        overall: toMarketsStatusOverall(x.marketStatus),
    };
}
const CANDLE_RESOLUTIONS = [1, 2, 3, 5, 10, 15, 20, 30, 60, 120, 240, 1440];
function fromCandleResolution(x) {
    var R = 1, D = Infinity;
    for (var r of CANDLE_RESOLUTIONS) {
        var d = Math.abs(x - r);
        if (d < D) {
            R = r;
            D = d;
        }
    }
    return R === 1440 ? "D" : R.toString();
}
function fromGetMarketHistory(x) {
    return {
        symbol: x.symbol,
        resolution: fromCandleResolution(x.resolution),
        date_format: 0,
        range_from: x.fromDate.toString(),
        range_to: x.toDate.toString(),
        cont_flag: x.continuous ? "1" : "0",
    };
}
function toCandleShort(x) {
    return {
        date: x[0 ],
        openPrice: x[1 ],
        highPrice: x[2 ],
        lowPrice: x[3 ],
        closePrice: x[4 ],
        volume: x[5 ],
    };
}
function toCandle(x) {
    return {
        date: x.t,
        openPrice: x.o,
        highPrice: x.h,
        lowPrice: x.l,
        closePrice: x.c,
        volume: x.v,
    };
}
function toMarketHistoryOverall(x) {
    var a = {
        fromDate: 0,
        toDate: 0,
        openPrice: 0,
        highPrice: 0,
        lowPrice: 0,
        closePrice: 0,
        volume: 0,
    };
    if (x.length === 0)
        return a;
    var l = x.length - 1;
    a.fromDate = x[0][0 ];
    a.toDate = x[l][0 ];
    a.openPrice = x[0][1 ];
    a.highPrice = x[0][2 ];
    a.lowPrice = x[0][3 ];
    a.closePrice = x[l][4 ];
    for (var c of x) {
        a.highPrice = Math.max(a.highPrice, c[2 ]);
        a.lowPrice = Math.min(a.lowPrice, c[3 ]);
        a.volume += c[5 ];
    }
    return a;
}
function toMarketHistory(x) {
    return {
        details: x.candles.map(toCandleShort),
        overall: toMarketHistoryOverall(x.candles),
    };
}
function toMarketQuote(x) {
    var v = x.v;
    return {
        symbol: x.n,
        token: v.fyToken,
        name: v.short_name,
        exchange: v.exchange,
        description: v.description,
        priceChange: v.ch,
        priceChangePercent: v.chp,
        currentPrice: v.lp,
        priceSpread: v.spread,
        askPrice: v.ask,
        bidPrice: v.bid,
        openPrice: v.open_price,
        highPrice: v.high_price,
        lowPrice: v.low_price,
        closePrice: v.prev_close_price,
        volume: v.volume,
        date: v.tt,
        candle: v.cmd ? toCandle(v.cmd) : null,
    };
}
function toMarketOffer(x) {
    return {
        price: x.price,
        volume: x.volume,
        orders: x.ord,
    };
}
function toMarketOfferL2(x, p) {
    return {
        price: x.price / p,
        volume: x.volume,
        orders: x.ord,
    };
}
function toMarketDepth(x) {
    var ks = Object.keys(x.d);
    if (ks.length === 0)
        return null;
    var s = ks[0];
    var v = x.d[s];
    return {
        symbol: s,
        token: null,
        name: symbolName(s),
        exchange: symbolExchange(s),
        expiryDate: v.expiry,
        currentPrice: v.ltq,
        lowerCircuitPrice: v.lower_ckt,
        upperCircuitPrice: v.upper_ckt,
        openPrice: v.o,
        highPrice: v.h,
        lowPrice: v.l,
        closePrice: v.c,
        volume: v.v,
        priceChange: v.ch,
        priceChangePercent: v.chp,
        openInterest: v.oi,
        previousOpenInterest: v.pdoi,
        openInterestChangePercent: v.oipercent,
        tradedQuantity: v.ltq,
        tradedDate: v.ltt,
        tradedPrice: v.atp,
        bidQuantity: v.totalbuyqty,
        askQuantity: v.totalsellqty,
        bids: v.bids.map(toMarketOffer),
        asks: v.ask.map(toMarketOffer),
    };
}
function toEdisTransaction(x) {
    return {
        id: x.transactionId,
        isin: x.isin,
        quantity: x.qty,
        remainingQuantity: x.qty - x.qtyUtlize,
        entryDate: x.entryDate,
        startDate: x.startDate,
        endDate: x.endDate,
        source: x.source,
        status: x.status,
        clientId: x.clientId,
        errorCode: x.errCode,
        errorCount: x.errorCount,
        reason: x.reason,
    };
}
function toEdisTransactionsOverall(x) {
    var a = {
        count: 0,
        quantity: 0,
        remainingQuantity: 0,
    };
    for (var t of x) {
        a.count++;
        a.quantity += t.qty;
        a.remainingQuantity += t.qty - t.qtyUtlize;
    }
    return a;
}
function toEdisTransactions(x) {
    var ts = x.data.length === 0 ? [] : x.data;
    return {
        details: ts.map(toEdisTransaction),
        overall: toEdisTransactionsOverall(ts),
    };
}
function fromEdisHolding(x) {
    return {
        isin_code: x.isin,
        qty: x.quantity,
    };
}
function toOrderUpdateNotification(x) {
    var d = x.d;
    return {
        id: d.id,
        symbol: d.symbol,
        token: d.fyToken,
        type: toOrderType(d.type),
        side: toOrderSide(d.side),
        productType: toProductType(d.productType),
        status: toOrderStatus(d.status),
        validity: toOrderValidity(d.orderValidity),
        offline: d.offlineOrder,
        quantity: d.qty,
        remainingQuantity: d.remainingQuantity,
        filledQuantity: d.filledQty,
        disclosedQuantity: d.discloseQty,
        remainingDisclosedQuantity: d.dqQtyRem,
        limitPrice: d.limitPrice,
        stopPrice: d.stopPrice,
        date: d.orderDateTime,
        parentId: d.parentId || null,
        tradedPrice: d.tradedPrice,
        message: d.message,
    };
}
function toMarketDataNotification(x, map) {
    var d = x.d;
    var t = d.token.toString();
    var p = d.price_conv || 1;
    var s = map != null ? map.get(t) || null : null;
    var priceChange = d.ltp - d.prev_close_price;
    var bid = d.bids == null ? d.bid : d.bids[0].price;
    var ask = d.asks == null ? d.ask : d.asks[0].price;
    return {
        symbol: s,
        token: t,
        name: s != null ? symbolName(s) : null,
        exchange: s != null ? symbolExchange(s) : null,
        date: d.tt,
        marketStatus: d.marketStat,
        currentPrice: d.ltp / p,
        openPrice: d.open_price / p,
        highPrice: d.high_price / p,
        lowPrice: d.low_price / p,
        closePrice: d.prev_close_price / p,
        priceChange: priceChange / p,
        priceChangePercent: priceChange / d.prev_close_price,
        candle: {
            date: d.tt,
            openPrice: d.o / p,
            highPrice: d.h / p,
            lowPrice: d.l / p,
            closePrice: d.c / p,
            volume: Number(d.v),
        },
        openInterest: Number(d.oi),
        previousOpenInterest: Number(d.pdoi),
        tradedQuantity: d.LTQ,
        tradedDate: d.L2_LTT,
        tradedPrice: d.ATP / p,
        volume: d.volume,
        bidQuantity: Number(d.tot_buy),
        askQuantity: Number(d.tot_sell),
        bidPrice: bid / p,
        askPrice: ask / p,
        priceSpread: (ask - bid) / p,
        bids: d.bids == null ? null : d.bids.map(x => toMarketOfferL2(x, p)),
        asks: d.asks == null ? null : d.asks.map(x => toMarketOfferL2(x, p)),
    };
}
function charge(x, p) {
    return 0.01 * Math.round(x * p);
}
function equityDeliveryBuyCharges(x) {
    var sttctt = charge(x, 0.10);
    var gst = charge(sttctt, 18.0);
    var exch = charge(x, 0.00325);
    var stamp = charge(x, 0.015);
    var sebi = charge(x, 0.0001);
    return sttctt + gst + exch + stamp + sebi;
}
function equityDeliverySellCharges(x) {
    var debit = 7.00 + 5.50;
    return debit + equityDeliveryBuyCharges(x);
}
function equityDeliveryCharges(side, value) {
    if (side === "BUY")
        return equityDeliveryBuyCharges(value);
    return equityDeliverySellCharges(value);
}
function equityIntradayBuyCharges(x) {
    var broker = Math.min(20.00, charge(x, 0.03));
    var gst = charge(broker, 18.0);
    var exch = charge(x, 0.00325);
    var stamp = charge(x, 0.003);
    var sebi = charge(x, 0.0001);
    return broker + gst + exch + stamp + sebi;
}
function equityIntradaySellCharges(x) {
    var broker = Math.min(20.00, charge(x, 0.03));
    var sttctt = charge(x, 0.025);
    var gst = charge(broker + sttctt, 18.0);
    var exch = charge(x, 0.00325);
    var stamp = charge(x, 0.003);
    var sebi = charge(x, 0.0001);
    return broker + sttctt + gst + exch + stamp + sebi;
}
function equityIntradayCharges(side, value) {
    if (side === "BUY")
        return equityIntradayBuyCharges(value);
    return equityIntradaySellCharges(value);
}
function equityFuturesBuyCharges(x) {
    var broker = Math.min(20.00, charge(x, 0.03));
    var gst = charge(broker, 18.0);
    var exch = charge(x, 0.0019);
    var clear = charge(x, 0.0005);
    var stamp = charge(x, 0.002);
    var sebi = charge(x, 0.0001);
    return broker + gst + exch + clear + stamp + sebi;
}
function equityFuturesSellCharges(x) {
    var broker = Math.min(20.00, charge(x, 0.03));
    var sttctt = charge(x, 0.01);
    var gst = charge(broker + sttctt, 18.0);
    var exch = charge(x, 0.0019);
    var clear = charge(x, 0.0005);
    var stamp = charge(x, 0.002);
    var sebi = charge(x, 0.0001);
    return broker + sttctt + gst + exch + clear + stamp + sebi;
}
function equityFuturesCharges(side, value) {
    if (side === "BUY")
        return equityFuturesBuyCharges(value);
    return equityFuturesSellCharges(value);
}
function equityOptionsBuyCharges(x) {
    var broker = 20.00;
    var gst = charge(broker, 18.0);
    var exch = charge(x, 0.053);
    var clear = charge(x, 0.009);
    var stamp = charge(x, 0.003);
    var sebi = charge(x, 0.0001);
    return broker + gst + exch + clear + stamp + sebi;
}
function equityOptionsSellCharges(x) {
    var broker = 20.00;
    var sttctt = charge(x, 0.05);
    var gst = charge(broker + sttctt, 18.0);
    var exch = charge(x, 0.053);
    var clear = charge(x, 0.009);
    var stamp = charge(x, 0.003);
    var sebi = charge(x, 0.0001);
    return broker + sttctt + gst + exch + clear + stamp + sebi;
}
function equityOptionsCharges(side, value) {
    if (side === "BUY")
        return equityOptionsBuyCharges(value);
    return equityOptionsSellCharges(value);
}
function currencyFuturesBuySellCharges(x) {
    var broker = Math.min(20.00, charge(x, 0.03));
    var gst = charge(broker, 18.0);
    var exch = charge(x, 0.00115);
    var clear = charge(x, 0.0005);
    var stamp = charge(x, 0.0001);
    var sebi = charge(x, 0.0001);
    return broker + gst + exch + clear + stamp + sebi;
}
function currencyFuturesCharges(side, value) {
    return currencyFuturesBuySellCharges(value);
}
function currencyOptionsBuySellCharges(x) {
    var broker = 20.00;
    var gst = charge(broker, 18.0);
    var exch = charge(x, 0.04);
    var clear = charge(x, 0.009);
    var stamp = charge(x, 0.0001);
    var sebi = charge(x, 0.0001);
    return broker + gst + exch + clear + stamp + sebi;
}
function currencyOptionsCharges(side, value) {
    return currencyOptionsBuySellCharges(value);
}
function commodityFuturesBuyCharges(x) {
    var broker = Math.min(20.00, charge(x, 0.03));
    var gst = charge(broker, 18.0);
    var exch = charge(x, 0.0026);
    var clear = charge(x, 0.0018);
    var stamp = charge(x, 0.002);
    var sebi = charge(x, 0.0001);
    return broker + gst + exch + clear + stamp + sebi;
}
function commodityFuturesSellCharges(x) {
    var broker = Math.min(20.00, charge(x, 0.03));
    var sttctt = charge(x, 0.01);
    var gst = charge(broker + sttctt, 18.0);
    var exch = charge(x, 0.0026);
    var clear = charge(x, 0.0018);
    var stamp = charge(x, 0.002);
    var sebi = charge(x, 0.0001);
    return broker + sttctt + gst + exch + clear + stamp + sebi;
}
function commodityFuturesCharges(side, value) {
    if (side === "BUY")
        return commodityFuturesBuyCharges(value);
    return commodityFuturesSellCharges(value);
}
function commodityOptionsBuyCharges(x) {
    var broker = 20.00;
    var gst = charge(broker, 18.0);
    var clear = charge(x, 0.05);
    var stamp = charge(x, 0.0003);
    var sebi = charge(x, 0.0001);
    return broker + gst + clear + stamp + sebi;
}
function commodityOptionsSellCharges(x) {
    var broker = 20.00;
    var sttctt = charge(x, 0.05);
    var gst = charge(broker + sttctt, 18.0);
    var clear = charge(x, 0.05);
    var stamp = charge(x, 0.0003);
    var sebi = charge(x, 0.0001);
    return broker + sttctt + gst + clear + stamp + sebi;
}
function commodityOptionsCharges(side, value) {
    if (side === "BUY")
        return commodityOptionsBuyCharges(value);
    return commodityOptionsSellCharges(value);
}
class ApiError extends Error {
    constructor(code, message) {
        super(message);
        this.code = code;
        this.name = this.constructor.name;
        this.stack = (new Error(message)).stack;
    }
}
function loginStep1(appId, redirectUrl, state = "default") {
    return loginStep1$1(fromLoginStep1Request({ appId, redirectUrl, state }));
}
function loginStep2(appHash, authorizationCode) {
    return loginStep2$1(fromLoginStep2Request({ appHash, authorizationCode }));
}
function validateApiStatus(x) {
    if (x.s !== "ok")
        throw new ApiError(x.code, x.message);
}
function validateApiOrder(x) {
    if (x.id === "")
        throw new ApiError(x.code, x.message);
}
async function getProfile(auth) {
    var a = await getProfile$1(fromAuthorization(auth));
    validateApiStatus(a);
    return toProfile(a);
}
async function getFunds(auth) {
    var a = await getFunds$1(fromAuthorization(auth));
    validateApiStatus(a);
    return toFunds(a);
}
async function getHoldings(auth) {
    var a = await getHoldings$1(fromAuthorization(auth));
    validateApiStatus(a);
    return toHoldings(a);
}
async function getOrder(auth, id) {
    var a = await getOrder$1(fromAuthorization(auth), { id });
    validateApiStatus(a);
    return toOrder(a.orderBook[0]);
}
async function getOrders(auth) {
    var a = await getOrders$1(fromAuthorization(auth));
    validateApiStatus(a);
    return toOrders(a);
}
async function getPositions(auth) {
    var a = await getPositions$1(fromAuthorization(auth));
    validateApiStatus(a);
    return toPositions(a);
}
async function getTrades(auth) {
    var a = await getTrades$1(fromAuthorization(auth));
    validateApiStatus(a);
    return toTrades(a);
}
async function placeOrder(auth, order) {
    var a = await placeOrder$1(fromAuthorization(auth), fromPlaceOrder(order));
    validateApiOrder(a);
    return a.id;
}
function placeOrders(auth, orders) {
    var p = placeOrders$1(fromAuthorization(auth), orders.map(fromPlaceOrder));
    return orders.map((_, i) => p.then(a => {
        validateApiStatus(a);
        validateApiOrder(a.data[i].body);
        return a.data[i].body.id;
    }));
}
async function modifyOrder(auth, order) {
    var a = await modifyOrder$1(fromAuthorization(auth), fromModifyOrder(order));
    validateApiStatus(a);
    return a.id;
}
function modifyOrders(auth, orders) {
    var p = modifyOrders$1(fromAuthorization(auth), orders.map(fromModifyOrder));
    return orders.map((_, i) => p.then(a => {
        validateApiStatus(a);
        validateApiOrder(a.data[i].body);
    }));
}
async function cancelOrder(auth, id) {
    var a = await cancelOrder$1(fromAuthorization(auth), { id });
    validateApiStatus(a);
}
function cancelOrders(auth, ids) {
    var p = cancelOrders$1(fromAuthorization(auth), ids.map(id => ({ id })));
    return ids.map((_, i) => p.then(a => {
        validateApiStatus(a);
        validateApiOrder(a.data[i].body);
    }));
}
async function exitPosition(auth, id) {
    var a = await exitPosition$1(fromAuthorization(auth), { id });
    validateApiStatus(a);
}
async function exitAllPositions(auth) {
    var a = await exitAllPositions$1(fromAuthorization(auth));
    validateApiStatus(a);
}
async function convertPosition(auth, conversion) {
    var a = await convertPosition$1(fromAuthorization(auth), fromConvertPosition(conversion));
    validateApiStatus(a);
}
async function getMarketStatus(auth) {
    var a = await getMarketStatus$1(fromAuthorization(auth));
    validateApiStatus(a);
    return toMarketsStatus(a);
}
async function getMarketHistory(auth, market) {
    var a = await getMarketHistory$1(fromAuthorization(auth), fromGetMarketHistory(market));
    validateApiStatus(a);
    return toMarketHistory(a);
}
async function getMarketQuotes(auth, symbols) {
    var a = await getMarketQuotes$1(fromAuthorization(auth), { symbols: symbols.join() });
    validateApiStatus(a);
    return a.d.map(toMarketQuote);
}
async function getMarketDepth(auth, symbol) {
    var a = await getMarketDepth$1(fromAuthorization(auth), { symbol, ohlcv_flag: 1 });
    validateApiStatus(a);
    return toMarketDepth(a);
}
function getSymbolMaster(auth, exchange, segment) {
    return getSymbolMaster$1(null, { exchange, segment });
}
function processSymbolMaster(csv) {
    var a = [];
    var RLINE = /[^\n]+/g, m = null;
    while ((m = RLINE.exec(csv)) != null)
        a.push(toSymbolDetails(m[0]));
    return a;
}
async function loadSymbolMaster(auth, exchange, segment) {
    var csv = await getSymbolMaster(null, exchange, segment);
    return processSymbolMaster(csv);
}
async function generateEdisTpin(auth) {
    var a = await generateEdisTpin$1(fromAuthorization(auth));
    validateApiStatus(a);
}
async function getEdisTransactions(auth) {
    var a = await getEdisTransactions$1(fromAuthorization(auth));
    validateApiStatus(a);
    return toEdisTransactions(a);
}
function submitEdisHoldingsStep(auth, holdings) {
    return submitEdisHoldingsStep$1(fromAuthorization(auth), { recordLst: holdings.map(fromEdisHolding) });
}
async function inquireEdisTransaction(auth, id) {
    var a = await inquireEdisTransaction$1(fromAuthorization(auth), { transactionId: id });
    validateApiStatus(a);
    return a.data.FAILED_CNT > 0 ? -a.data.FAILED_CNT : a.data.SUCEESS_CNT;
}
function connectOrderUpdate(auth, fn) {
    return connectOrderUpdate$1(fromAuthorization(auth), x => {
        if (x.d)
            fn(toOrderUpdateNotification(x));
    });
}
async function subscribeOrderUpdate(conn) {
    var a = await subscribeOrderUpdate$1(conn);
    if (a.code < 0)
        throw new ApiError(a.code, a.message);
}
async function unsubscribeOrderUpdate(conn) {
    var a = await unsubscribeOrderUpdate$1(conn);
    if (a.code < 0)
        throw new ApiError(a.code, a.message);
}
function connectMarketData(auth, fn, map = null) {
    return connectMarketData$1(fromAuthorization(auth), x => {
        if (x.d)
            fn(toMarketDataNotification(x, map));
    });
}
async function subscribeMarketQuote(conn, symbols) {
    var a = await subscribeMarketQuote$1(conn, symbols);
    if (a.code < 0)
        throw new ApiError(a.code, a.message);
}
async function subscribeMarketDepth(conn, symbols) {
    var a = await subscribeMarketDepth$1(conn, symbols);
    if (a.code < 0)
        throw new ApiError(a.code, a.message);
}
async function unsubscribeMarketQuote(conn, symbols) {
    var a = await unsubscribeMarketQuote$1(conn, symbols);
    if (a.code < 0)
        throw new ApiError(a.code, a.message);
}
async function unsubscribeMarketDepth(conn, symbols) {
    var a = await unsubscribeMarketDepth$1(conn, symbols);
    if (a.code < 0)
        throw new ApiError(a.code, a.message);
}
class Api {
    constructor(appId, accessToken) {
        this.appId = appId;
        this.accessToken = accessToken;
        this.symbolDetails = new Map();
        this.tokenSymbol = new Map();
        this.orderUpdateConnection = null;
        this.marketDataConnection = null;
    }
    static loginStep1(appId, redirectUrl, state = "default") {
        return loginStep1(appId, redirectUrl, state);
    }
    static loginStep2(appHash, authorizationCode) {
        return loginStep2(appHash, authorizationCode);
    }
    static getSymbolMaster(exchange, segment) { return getSymbolMaster(null, exchange, segment); }
    getProfile() { return getProfile(this); }
    getFunds() { return getFunds(this); }
    getHoldings() { return getHoldings(this); }
    getOrder(id) { return getOrder(this, id); }
    getOrders() { return getOrders(this); }
    getPositions() { return getPositions(this); }
    getTrades() { return getTrades(this); }
    placeOrder(order) { return placeOrder(this, order); }
    placeOrders(orders) { return placeOrders(this, orders); }
    modifyOrder(order) { return modifyOrder(this, order); }
    modifyOrders(orders) { return modifyOrders(this, orders); }
    cancelOrder(id) { return cancelOrder(this, id); }
    cancelOrders(ids) { return cancelOrders(this, ids); }
    exitPosition(id) { return exitPosition(this, id); }
    exitAllPositions() { return exitAllPositions(this); }
    convertPosition(conversion) { return convertPosition(this, conversion); }
    getMarketStatus() { return getMarketStatus(this); }
    getMarketHistory(market) { return getMarketHistory(this, market); }
    getMarketQuotes(symbols) { return getMarketQuotes(this, symbols); }
    getMarketDepth(symbol) { return getMarketDepth(this, symbol); }
    processSymbolMaster(csv) {
        var rs = processSymbolMaster(csv);
        for (var r of rs) {
            this.symbolDetails.set(r.symbol, r);
            this.tokenSymbol.set(r.token, r.symbol);
        }
        return rs;
    }
    async loadSymbolMaster(exchange, segment) {
        var rs = await loadSymbolMaster(null, exchange, segment);
        for (var r of rs) {
            this.symbolDetails.set(r.symbol, r);
            this.tokenSymbol.set(r.token, r.symbol);
        }
        return rs;
    }
    generateEdisTpin() { return generateEdisTpin(this); }
    getEdisTransactions() { return getEdisTransactions(this); }
    submitEdisHoldingsStep(holdings) { return submitEdisHoldingsStep(this, holdings); }
    inquireEdisTransaction(id) { return inquireEdisTransaction(this, id); }
    connectOrderUpdate(fn) {
        if (this.orderUpdateConnection != null)
            this.orderUpdateConnection.then(c => c.close());
        return this.orderUpdateConnection = connectOrderUpdate(this, fn);
    }
    async subscribeOrderUpdate() {
        return subscribeOrderUpdate(await this.orderUpdateConnection);
    }
    async unsubscribeOrderUpdate() {
        return unsubscribeOrderUpdate(await this.orderUpdateConnection);
    }
    async connectMarketData(fn) {
        if (this.marketDataConnection != null)
            this.marketDataConnection.then(c => c.close());
        return this.marketDataConnection = connectMarketData(this, fn, this.tokenSymbol);
    }
    async subscribeMarketQuote(symbols) {
        return subscribeMarketQuote(await this.marketDataConnection, symbols);
    }
    async subscribeMarketDepth(symbols) {
        return subscribeMarketDepth(await this.marketDataConnection, symbols);
    }
    async unsubscribeMarketQuote(symbols) {
        return unsubscribeMarketQuote(await this.marketDataConnection, symbols);
    }
    async unsubscribeMarketDepth(symbols) {
        return unsubscribeMarketDepth(await this.marketDataConnection, symbols);
    }
}

export { Api, cancelOrder, cancelOrders, commodityFuturesCharges, commodityOptionsCharges, connectMarketData, connectOrderUpdate, convertPosition, currencyFuturesCharges, currencyOptionsCharges, derivativeType, derivativeTypeDescription, equityDeliveryCharges, equityFuturesCharges, equityIntradayCharges, equityOptionsCharges, exchange, exchangeDescription, exitAllPositions, exitPosition, generateEdisTpin, getEdisTransactions, getFunds, getHoldings, getMarketDepth, getMarketHistory, getMarketQuotes, getMarketStatus, getOrder, getOrders, getPositions, getProfile, getSymbolMaster, getTrades, holdingType, holdingTypeDescription, http, inquireEdisTransaction, instrumentType, instrumentTypeDescription, loadSymbolMaster, loginStep1, loginStep2, modifyOrder, modifyOrders, optionType, optionTypeDescription, orderSide, orderSideDescription, orderSource, orderSourceDescription, orderStatus, orderStatusDescription, orderType, orderTypeDescription, orderValidity, orderValidityDescription, placeOrder, placeOrders, positionSide, positionSideDescription, processSymbolMaster, productType, productTypeDescription, segment, segmentDescription, submitEdisHoldingsStep, subscribeMarketDepth, subscribeMarketQuote, subscribeOrderUpdate, symbolDerivativeType, symbolDescription, symbolExchange, symbolIsin, symbolLotSize, symbolName, symbolOptionType, symbolSeries, symbolStrikePrice, symbolToken, unsubscribeMarketDepth, unsubscribeMarketQuote, unsubscribeOrderUpdate, websocket };
